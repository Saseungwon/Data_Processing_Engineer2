## ✍ 1장 소프트웨어 개발방법론


#### 소프트웨어 생명주기

1. 소프트웨어 생명주기 모델 프로세스 

**💖요설구테유**
요구사항부석
설계
구현
테스트
유지보수


2. 소프트웨어 생명주기 모델 종류 

**💖폭프나반**

폭포수 모델
프로토타이핑 모델
나선형 모델(**💖계위개고**) 
- 계획및정의
- 위험분석
- 개발
- 고객평가

반복적 모델 : 병렬적으로 개발, 반복적으로 점증 완성시킴 


#### 소프트웨어 개발방법론 

1.  소프트웨어 개발방법론 종류 

(1) 구조적 방법론
- 기능에 따라 나누어 개발
- 분할과 정복
- 나씨 슈나이더만 차트 사용(논리의 기술에 중점, 시각적으롤 명확히 식별하는 데 적합)

(2) 정보공학 방법론 : 정보시스템 개발에 적합 

(3) 객체지향 방법론 : 객체 

(4) 컴포넌트 기반 방법론 : 컴포넌트롤 조립해서 새로운 프로그램 작성

(5) 애자일 방법론 : 사람 중심 

(6) 제품 계열 방법론
- 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발 
- 임베디드 소프트웨어에 유용
- 영역 공학과 응용 공학으로 구분 


2. 애자일 

(1) XP의 5가지 가치
**💖용단의피존**
용기
단순성
의사소통
피드백 
존중 

(2) XP의 12가지 기본원리 
짝 프로그래밍
공동 코드 소유 
지속적인 통합 
계획 세우기 
작은 릴리즈 
메타포어 
간단한 디자인
테스트 기반 개발 TDD
리팩토링 
40시간 작업 
고객 상주 
코드 표준 

(3) 스크럼 
백로그 : 요구사항 
스프린트 : 2~4주의 짧은 개발 기간 
스크럼 미팅 : 매일 15분 정도 미팅 
스크럼 마스터 : 리더 
스프린트 회고  : 스프린트 주기를 되돌아봄
번 다운 차트 : 남아있는 백로그 대비 기간을 그래픽적으로 표현한 차트 

(4) 린 : 낭비 요소를 제거하여 품질을 향상시킨 방법론 


#### 비용산정 모형 종류 

1. Loc 모형
- 낙관치, 중간치, 비관치를 측정해 예측치 구함 
- 예측치 : 낙관치 + 4중간치 + 비관치 / 낙관치 

2. Man Month 모형 
- Man Month = Loc / 프로그래머의 월간 생산성 
- 프로젝트 기간 = Man Month / 프로젝트 인력 

3. COCOMO 모형
- 보헴 
- 규모에 따라 조직형, 반 분리형, 임베디드형으로 나뉨 
- 조직형 : 자료처리나 과학 기술 계산용(5만 이하)
- 반 분리형 : 트랜잭션 처리, 컴파일러, 인터프리터(30만 이하)
- 임베디드형 : 초대형 규모 운영체제, 실시간 처리 시스템(30만 이상)

4. 푸트남 모형 
- 단계별로 요구할 인력의 분포를 가정하는 방식 
- 생명주기 예측 모형 
- Rayleigh-Norden 곡선 

5. 기능점수 모형
- 인자별로 가중치 부여, 요인별 가중치를 합산하여 총 기능의 점수를 계산 
- 단순, 보통, 복잡한 정도에 따라 가중치를 부여한다. 


#### 일정관리 모델 
(1) 개념 : 기한 내에 적잘하게 완료될 수 있도록 관리하는 모델 

(2) 종류 
- 주 공정법 : 프로젝트의 일정을 계산하는 기법, 프로젝트의 시작과 끝을 나타내는 노드와 노드 간을 연결을 통해 공정을 계산하기 위한 액트비티 표기법 
- PERT : 비관치, 중간치, 낙관치의 3점 추정 방식을 통해 일정을 관리 
- 중요 연쇄 프로젝트 관리 : 자원제약사항을 고려하여 일정을 작성하는 기법 



## ✍ 2장 현행 시스템 분석 

#### 현행 시스템 파악 절차 
구기인 아소 하네 

#### 소프트웨어 아키텍처

(1) 소프트웨어 아키텍처 개념
외부에 드러나는 특성, 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체 

(2) 소프트웨어 아키텍처 프레임워크

개념 : 아키텍처가 표현해야하는 내용 및 이들 간의 관계를 제공하는 아케텍처 기술 표준

#### 소프트웨어 아키텍처 4+1뷰

**💖유논프구배**
4+1에서 1은 유스케이스 뷰, 4는 논리/구현/프로세스/배포 뷰 

유스케이스 뷰 : 다른 뷰를 검증하는 데 사용되는 뷰 
논리 뷰 : 기능적인 요구사항
프로세스 뷰 : 비기능적인 속성 
구현 뷰 : 모듈의 구성을 보여주는 뷰 
배포 뷰 : 컴포넌트가 어떻게 배치되는가를 보여주는 뷰 

#### 소프트웨어 아키텍처 패턴 

(1) 개념 : 소프트웨어 아키텍츠 패턴은 소프트웨어를 설계할 때 참조할 수 있는 전형적인 해결방식이다. 

(2) 유형 
- 계층화 패턴 : 서로 마주보는 두 개의 계층 사이에서만 상호작용 이루어짐 
- 클라이언트 서버 패턴 : 하나의 서버와 다수의 클라이언트로 구성된 패턴 
- 파이프 필터 패턴
- 브로커 패턴 : 서버는 자신의 기능들을 브로커에 넘겨주며, 클라이언트가 브롴커에 서비스를 요청하면 브로커는 클라이언트를 자신의 레지스트리에 있는 적합한 서비스로 리다이렉션함 
- 모델 뷰 컨트롤러 패턴 
  - 모델 : 핵심기능과 데이터 보관 
  - 뷰 : 사용자에게 정보 표시 
  - 컨트롤러 : 사용자로부터 요청을 입력받아 처리 

#### 소프트웨어 아키텍처 비용 평가 모델 

(1) 개념 : 소프트웨어 아키텍처 비용 평가 모델은 아키텍처의 적합성을 평가하는 모델이다. 

(2) 종류 (**💖SACAA**)
- SAAM : 경험이 없는 조직에서도 활용 가능 
- ATAM : 아키텍처 품질 속성을 만족시키는지 판단
- CBAM : 경제적 의사결정에 대한 요구 충족하는지 판단 
- ADR : 응집도 평가 
- ARID : 특정 부분에 대한 품질요소에 집중 

#### 디자인 패턴 

(1) 개념 : 디자인 패턴은 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴이다.

(2) 유형(**💖생구행**)
- 생성 
- 구조 
- 행위

(3) 종류 

생성패턴 (**💖생 빌 프로 팩 앱 싱**)
- Builder
  - 조립하여 만드는 구조 
- Prototype
  - 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정해 사용 
- Factory Method
  - 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위클래스에서 인스턴스 생성 하는 방식 
- Abstract Factory
  - 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 페턴 
- Singleton
  - 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴


구조패턴 (**💖구 브 데 퍼 플 프록 컴 어**)
- Bridge
  - 기능의 클래스 계층과 구현의 클래스 계층을 연결  
- Decorator
  - 기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 설계 패턴
- Facade
  - 복잡한 시스템에 대해 단순한 인터페이스를 제공함으로써 구조에 대한 파악 쉽게하는 패턴 
- Flyweight
  - 공유함으로써 메모리를 절약하고 클래스의 경량화를 목적
- Proxy
  - 실체 객체에 대한 대리 객체 
- Composite
  - 객체들의 관계를 트리 구조로 구성하여 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 패턴
- Adapter
  - 기존에 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴 



행위패턴 (**💖행 미 인 이 템 옵 스테 비 커 스트 메 체**)
- Mediator(중재자)
  - 중간에 이를 통제하고 지시할 수 있는 역할을 하는 중재자를 두고, 통신의 빈도수를 줄여 객체 지향을 목표를 달성하게 해주는 디자인 패턴
- Interpreter
  - 해석, 여러 형태의 언어 구문을 해석할 수 있게 만드는 디자인 패턴
- Iterator(반복자)
  - 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 방법을 제공하는 디자인 패턴
- Template Method
  - 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴으로 상위 클래스에는 추상 메소드를 통해 기능의 골격을 제공하고 하위클래스 메서드에는 세부 처리를 구체화하는 방식
- Observer
  - 한 객체의 상태가 바뀌면 다른 객체들에 연락이 가고 자동으로 내용이 갱신됨
- State
  - 객체 상태를 캡슐화하여 상태에 따라 다르게 처리할 수 있도록 행위 내요을 변경 
- Visitor
  - 각 클래스를 돌아다니면 특정 작업을 수행
- Command
  - 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되
- Strategy(전략)
  - 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴 
- Memento
  - Undo 기능을 개발할 때 사용하는 디자인 패턴 Ctrl Z
- Chain of Responsibility
  - 정적으로 어떤 기능에 대한 처리의 연결이 하드코딩 되어 있을 때 기능 처리의 연결 변경이 불가능한데, 이를 동적으로 연결되어 있는 경우에 따라 다르게 처리될 수 있도록 연결한 디자인 패턴 

#### 운영체제 현행 시스템 분석

(1) 운영체제 현행 시스템 분석 시 고려 사항(**💖신성기주구**)
신뢰도 
성능
기술지원
주변기기
구축비용


