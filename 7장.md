## 📚 CHAPTER1 데이터베이스 기본 

### ✍ 트랜잭션

#### 1. 트랜잭션 개념
데이터베이스 시스템에서 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위 

#### 2. 트랜잭션 특성 (ACID / 원일격영)
- 원자성(Atomicity)
  - 연산전체가 성공 또는 실패
  - 하나 실패하면 전체 취소
  - Commit/Rollback, 회복성 보장
- 일관성(Consistency)
- 격리성(Isolation)
- 영속성(Durability)

#### 3. 트랜잭션의 상태 변화 (활부완실철)
- 활동 상태
- 부분완료 상태
- 완료 상태
- 실패 상태
- 철회 상태

#### 4. 트랜잭션 제어 (커롤체)
- 트랜잭션 제어 언어 (TCL)
  - 커밋
  - 롤백 : 트랜잭션 내역을 저장 무효화 시키는 명령어 
  - 체크포인트


#### 5. 병행 제어

(1) 병행 제어 개념
- 다수 사용자 환경에서 여러 트랜잭션 수행 시, 데이터베이스 일관성 유지를 위해 상호작용을 제어하는 기법 

(2) 병행 제어 미보장 시 문제점 **(갱현모연)**
- 갱신 손실 : 먼저 실행된 트랜잭션 결과를 나중에 실행된 트랜잭션이 덮어쓸 때 발생
- 현황 파악오류 : 트랜잭션 중간 수행 결과를 다른 트랜잭션이 참조하여 발생
- 모순성 : 두 트랜잭션이 동시에 실행되어 데이터베이스의 일관성이 결여됨
- 연쇄복귀 : 특정 트랜잭션이 처리를 취소할 경우 트랜잭션이 처리한 곳의 부분을 취소하지 못함

(3) 병행 제어 기법의 종류 **(로낙타다)**
- 로킹 
  - 같은 자원을 액세스하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보장하는 직렬화 기법(누가 쓰고 있으면 다음 사람은 기다려)
  - 특징 
    - 데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있음
    - 로킹 단위가 작아지면 데이터베이스 공유도 증가 
    - 로킹 단위가 작아지면 로킹 오버헤드가 증가 
    - 한꺼번에 로킹할 수 있는 객체의 크기를 로킹 단위라고 함
- 낙관적 검증
  - 어떠한 검증도 수행하지 않고 일단 트랜잭션을 수행하고, 트랜잭션 종료 시 검증을 수행하여 데이터베이스에 반영하는 기법
- 타임 스탬프 순서
  - 트랜잭션이 실행을 시작하기 전에 타임 스탬프를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법
- 다중버전 동시성 제어(MVCC)
  - 트랜잭션의 타임스탬프와 접근하려는 데이터의 타임스탬프를 비교하여 직렬가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법 

#### 6. 데이터베이스 고립화 수준 (RRRS)
(1) 고립화 수준 개념 
고립화 수준은 다른 트랜잭션이 현재의 데이터에 대한 무결성을 해치지 않기 위해 잠금을 설정하는 정도 

(2) 고립화 수준 종류 
- Read Uncommitted : 연산중인 데이터를 다른 트랜잭션이 읽는 것을 허용
- Read Committed : 연산이 완료될 때까지 연산 대상 데이터에 대한 읽기를 제한
- Repeatable Read : 선행 트랜잭션 실행 시, 종료시까지 해당 데이터에 대한 갱신, 삭제 제한
- Serializable Read : 선행 트랜잭션이 순차적으로 읽을 때, 해당 데이터 영역 전체에 대한 접근 제한

#### 7. 회복 기법 종류 (회로체크)
- 로그 기반 회복 기법 
  - 지연 갱신 회복 기법 : 완료되기 전까지 데이터베이스에 기록하지 않는 기법
  - 즉각 갱신 회복 기법 : 수행 중 갱신 결과를 바로 DB에 반영
- 체크 포인트 회복 기법 
  - 검사점 이후에 처리된 트랜잭션에 대해서만 장애 발생 이전의 상태로 복원시키는 회복 기법
- 그림자 페이징 회복 기법 
  - 복제본을 생성하여 데이터베이스 장애 시 이를 이용해 복구하는 기법
<br>


### ✍ DDL
#### 1. 데이터 정의어(DDL)
#### 2. DDL의 대상 
(1) DDL 대상 **(도스테뷰인)**
- 도메인 : 원자값들의 집합 
- 스키마 : 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조 
  - 외부 스키마 : 사용자 뷰 
  - 개념 스키마 
    - 데이터베이스의 전체적인 논리적 구조
    - 전체적인 뷰
    - 관계, 제약조건, 접근 권한, 무결성, 보안에 대해 정의
  - 내부 스키마 : 물리적 저장장치의 관점에서 보는 데이터베이스 구조  
- 테이블 : 데이터 저장 공간 
- 뷰 : 하나 이상의 물리 테이블에서 유도되는 가상의 테이블 
- 인덱스 : 검색을 빠르게 하기 위한 데이터 구조 

(2) 테이블 관련 용어
- 튜플 / 행 : 튜플은 릴레이션에서 같은 값을 가질 수 없음 
- 애트리뷰트 / 열 : 열의 개수를 디그리라고 함 
- 식별자 : 각각의 구분할 수 있는 논리적인 개념 
- 카디널리티 : 튜플의 개수 
- 차수 : 애트리뷰트의 개수 
- 도메인 : 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값들의 집합 

(3) 뷰 
- 개념 : 논리 테이블이다. 
- 특징 
  - 논리적 데이터 독립성 제공 
  - 데이터 조작 연산 간소화
  - 보안 기능 제공 
  - 뷰 변경 불가 : ALTER로 변경 불가 / DROP으로 제거 후 재생성 해야됨 
  - 뷰를 통해 접근 가능한 데이터에 대한 변경 가능, But 일부 제약 존재
    - ex) 기본키에 해당하는 컬럼이 뷰에 정의되어 있지 않은 경우 INSERT 불가능
- 목적 : 하나의 뷰로 복수의 테이블을 대체, 중요 데이터 일부만을 제공할 수 있는 장단점

(4) 인덱스 
- 개념 : 데이터를 빠르게 찾을 수 있는 수단(유일해야하고, 중복이 있으면 안 됨)
- 종류 
  - 순서 인덱스 : 정렬된 순서로 생성 
  - 해시 인덱스 : 키 값으로 접근
  - 비트맵 인덱스 : 각 컬럼에 적은 개수 값이 저장된 경우 선택
  - 함수기반 인덱스 : 수식이나 함수를 적용하여 만든 인덱스
  - 단일 인덱스 : 하나의 컬럼으로만 적용
  - 결합 인덱스 : 두 개 이상의 컬럼으로 구성 
  - 클러스터드 인덱스 : 기본 키 기준으로 레코드를 묶어서 저장

- 인덱스 스캔 방식
  - 인덱스 범위 스캔 : 수직적으로 탐색한 후에 리프 블록을 필요한 범위만 스캔
  - 인덱스 전체 스캔 : 처음부터 끝까지 수평적 탐색
  - 인덱스 단일 스캔 : 수직적 탐색만 
  - 인덱스 생량 스캔 : 조건 절에 빠졌어도 인덱스를 활용하는 스캔

#### 3. DDL 명령어  (크알드트)
- CREATE
- ALTER
- DROP : 데이터베이스 오브젝트 삭제 (DELETE = DML)
- TRUNCATE : 데이터베이스 오브젝트 내용 삭제

#### 4. TABLE 관련 DDL

(1) CREATE TABLE 

- CREATE TABLE 제약조건
  - PRIMARY KEY : 기본키 정의 / 유일하게 테이블의 각 행을 식별 
  - FOREIGN KEY : 외래키 정의 / 참조 대상을 테이블로 명시
  - UNIQUE : 유일한 값을 갖도록 하는 제약조건 
  - NOT NULL : NULL 값을 포함하지 않도록 하는 제약조건
  - CHECK : 개발자가 정의하는 제약조건
  - DEFAULT : 기본값으로 설정해주는 제약조건


(2) ALTER TABLE  : 테이블 수정
- ALTER TABLE 컬럼 추가 문법 
  ```sql
  ALTER TABLE 테이블명 ADD 컬럼명 데이터타입 [제약조건];
  ```
- ALTER TABLE 컬럼 수정 문법 
  ```sql
  ALTER TABLE 테이블명 MODIFY 컬럼명 데이터타입 [제약조건];
  ```

- ALTER TABLE 컬럼명 수정 문법 
  ```sql
  ALTER TABLE 테이블명 RENAME COLUMN 변경전 TO 변경후;
  ```

- ALTER TABLE 컬럼 삭제 문법 
  ```sql
  ALTER TABLE 테이블명 DROP 컬럼명;
  ```

(3) DROP TABLE : 테이블 삭제 

- DROP TABLE 문법 
  ```sql
  DROP TABLE 테이블명 [CASCADE|RESTRICT];
  ```
  - CASCADE : 참조하는 테이블까지 연쇄적으로 제거
  - RESTRICT : 다른 테이블이 삭제할 테이블을 참조 중이면 제거하지 않는 옵션
  
(4) TRUNCATE TABLE : 테이블 내 데이터들을 삭제 (테이블은 삭제 X) 
- TRUNCATE TABLE 문법 
  ```sql
  TRUNCATE TABLE 테이블명;
  ```
  

#### 5. VIEW 관련 DDL 
(1) CREATE VIEW : 뷰 생성 
- CREATE VIEW 문법 
  ```sql
  CREATE VIEW 뷰이름 AS
  조회커리;
  ```

(2) CREATE OR REPLACE VIEW : 뷰 교체 
- CREATE OR REPLACE VIEW 문법 
  ```sql
  CREATE OR REPLACE VIEW 뷰이름 AS
  조회커리;
  ```

#### 6. INDEX 관련 DDL 

(1) CREATE INDEX
- UNIQUE 생략 가능 
- 중복 값 허용 X
- 복수 컬럼을 인덱스로 걸 수 있다.
  - CREATE INDEX 문법 
    ```sql
    CREATE [UNIQUE] INDEX 인덱스명 ON 테이블명(컬럼명1, 컬럼명2, ...);
    ```

(2) DROP INDEX : 인덱스 삭제 
- DROP INDEX 문법 
    ```sql
    DROP INDEX 인덱스명;
    ```

<br>


### ✍ DML

#### 1. 데이터 조작어 (CRUD)
입력, 수정, 삭제, 조회 

#### 2. DML 명령어 (세인업데)
SELECT, INSERT, UPDATE, DELETE 

#### 3. SELECT 명령어 (셀프웨구해오)
- SELECT
  - ALL : 기본값
  - DISTINCT : 중복된 속성이 조회될 경우 그중 한 개만 검색 
- FROM
- WHERE : 검색할 조건
- GROUP BY : 속성값을 그룹으로 분류 
- HAVING : GROUP BY에 의해 분류한 후 그룹에 대한 조건 지정
- ORDER BY : ASC 오름차 / DESC : 내림차

(1) SELECT 절 

(2) WHERE 절 
- WHERE 절 문법 
  - 비교 
    - <>,!= : 값이 다른 경우 조회
  - 범위 
    - BETEWEEN : 크거나 같고, 작거나 같은 데이터 조회(같은 포함 중요)
  - 집합 
    - IN : 컬럼이 IN 안에 포함된 경우의 데이터 조회
    - NOT IN : 컬럼이 IN 안에 포함되어 있지 않은 경우의 데이터 조회
  - 패턴 
    - LIKE
      - % : 0개 이상의 문자열과 일치
      - [] : 1개의 문자와 일치, [0-8]% : 0~8 사이 숫자로 시작 
      - [^] : 1개의 문자와 불일치, ^ [0-8]% : 0~8 사이 숫자로 시작하지 않는 문자열
  - NULL
    - IS NULL : 컬럼이 NULL인 데이터 조회 
    - IS NOU NULL : 컬럼이 NULL이 아닌 데이터 조회 

(3) GROUP BY 절 
연산 없는 컬럼만 GROUP BY 가능

(4) HAVING 절 
GROUP BY 절에 의해 분류한 후 그룹에 대한 조건 지정할 때 사용 

(5) ORDER BY 절 


#### 4. 조인
- 논리적 조인 유형 **(내외교셀)**
  - 내부 조인 : 공통 존재 컬럼의 값이 같은 경우를 추출 
  - 외부 조인
    - 왼쪽 외부 조인
    - 오른쪽 외부 조인
    - 완전 외부 조인 
  - 교차 조인 : 조인 조건이 없는 모든 데이터 조합을 추출 
  - 셀프 조인 : 자기 자신에게 별칭을 지정한 후 다시 조인 
<br>
      (1) 내부조인(Inner Join)
      - 같은 이름의 컬럼이 여러 테이블에 있을 경우 별칭.컬럼명 형태로 명시 
      - INNER 생략 가능
      ```sql
      SELECT A.컬럼1, A.컬럼2 ... B.컬럼1
      FROM 테이블1 A [INNER] JOIN 테이블2 B
      ON 조인조건 
      [WHERE 검색조건];    
      ```

      (2) 왼쪽 외부 조인(Left Outer Join)
      - OUTER 생략 가능
      ```sql
      SELECT A.컬럼1, A.컬럼2 ... B.컬럼1
      FROM 테이블1 A LEFT [OUTER] JOIN 테이블2 B
      ON 조인조건 
      [WHERE 검색조건];    
      ```

      (3) 오른쪽 외부 조인(Right Outer Join)
      ```sql
      SELECT A.컬럼1, A.컬럼2 ... B.컬럼1
      FROM 테이블1 A RIGHT [OUTER] JOIN 테이블2 B
      ON 조인조건 
      [WHERE 검색조건];    
      ```

      (4) 완전 외부 조인(Full Outer Join)
      ```sql
      SELECT A.컬럼1, A.컬럼2 ... B.컬럼1
      FROM 테이블1 A FULL [OUTER] JOIN 테이블2 B
      ON 조인조건 
      [WHERE 검색조건];    
      ```

      (5) 교차 조인(Cross Join)
      - 조인 조건이 없는 모든 데이터 조합을 추출하기 때문에 ON절이 없음
      ```sql
      SELECT 컬럼1, 컬럼2
      FROM 테이블1 CROSS JOIN 테이블2 
      [WHERE 검색조건];    
      ```


      (6) 셀프 조인(Self Join)
      - 같은 테이블명을 쓰고 별칭만 A,B와 같이 다르게 함
      ```sql
      SELECT A.컬럼1, A.컬럼2 ... B.컬럼1
      FROM 테이블1 A [INNER] JOIN 테이블1 B
      ON 조인조건 
      [WHERE 검색조건];    
      ```

- 물리적 조인 유형 **(네소해)**
  - 중첩 반복 조인(Nested Loop Join)
    - 2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방의 Row를 결합하여 원하는 결과를 조합하는 조인 방식
      ```
      선행 -> 후행 -> 조인 결과
      ```
  - 정렬 합병 조인(Sort Merge Join)
    - 조인의 대상 범위가 넓을 때 발생하는 임의 접근을 줄이기 위한 경우나 연결고리에 마땅한 인덱스가 존재하지 않을 경우 해결하기 위한 조인 방식
      ```
      선행 = 정렬 = 후행 
          합병(Merge)
      ```
  - 해시 조인(Hash Join)
    - 해싱함수를 활용하여 테이블 간 조인을 수행하는 방식 
      ```
        선행 - 후행 
         해시테이블
            결과
      ```
#### 5. 서브쿼리 (셀프웨)
(1) 개념 : 서브쿼리는 SQL 문 안에 포함된 또 다른 SQL 문이다.

(2) 유형 
- SELECT 절 서브쿼리 
  - 서브쿼리가 SELECT 절 안에 들어있음
  - 스칼라 서브쿼리라고 불림
  - 반드시 단일 행 리턴
  ```sql
  SELECT (SELECT MAX(가격)
            FROM 도서.A
            WHERE A.책번호 = B.책번호
            AND 책명 = '자료구조')
  FROM 도서가격 B; 
  ```

- FROM 절 서브쿼리
  - 서브쿼리가 FROM 절 안에 들어있음
  - 인라인 뷰라고 불림 
  - 뷰처럼 결과가 동적으로 생성된 테이블 형태로 사용할 수 있음 
    ```sql
    SELECT MAX(가격)
      FROM 도서가격 A,
              (SELECT 책번호
              FROM 도서 
              WHERE 책명 = '자료구조') B
    WHERE A.책번호 = B.책번호
    ```

- WHERE 절 서브쿼리 
  - 서브쿼리가 WHERE 절 안에 들어있음
  - 중첩 서브쿼리라고 불림
    ```sql
    SELECT MAX(가격)
      FROM 도서가격 
      WHERE 책번호 IN
              (SELECT 책번호
              FROM 도서 
              WHERE 책명 = '자료구조');
      ```

#### 6. 집합 연산자 (유올인마)
(1) 개념 : 2개 이상의 질의 결과를 하나의 결과로 만들어 준다. 

(2) 유형 
- UNION : 중복행 제거
- UNION ALL : 중복행 허용
- INTERSECT : 공통적으로 존재하는 결과 반환(중복 레코드만 포함) 
- MINUS : 첫 쿼리에 있고 두 번째 쿼리에는 없는 결과 반환(비교 레코드 제외 )

#### 7. INSERT 명령어 (인인밸)
```sql
INSERT INTO 테이블명(속성명1,...)
VALUES (데이터1, ...)
```

#### 8. UPDATE 명령어 (업셋웨)
```sql
UPDATE 테이블명
SET 속성명 = 데이터, ...
WHERE 조건;
```

#### 9. DELETE 명령어 (델프웨)
- 테이블은 완전히 삭제하는 DROP과는 다름 
```sql
DELETE FROM 테이블명
WHERE 조건;
```
<br>


### ✍ DCL

#### 1. 데이터 제어어(DCL)  (보무병회)
(1) 개념 : DB 관리자가 데이터 보안, 무결성 유지, 병행 제어, 회복을 위해 관리자(DBA)가 사용하는 제어용 언어

(2) 유형 
- GRANT : 사용 권한 부여  **(그온투)**
  ```sql
  GRANT 권한 ON 테이블 TO 사용자
  ```

- REVOKE : 사용 권한 취소 **(리온프)**
  ```sql
  REVOKE 권한 ON 테이블 FROM 사용자
  ```

(3) GRANT(권한부여) 명령어
- 객체권한 : 관리자가 사용자에게 테이블에 대한 권한을 부여 
  ```sql
  GRANT 권한 ON 테이블 TO 사용자
  ```

- 시스템권한 : 테이블, 뷰, 프로시저 등을 생성, 삭제 권한 부여 
  ```sql
  GRANT 권한  TO 사용자
  ```
- Ex) 관리자가 사용자에게 학생 테이블에 대해 UPDATE 할 수 있는 권한 부여 
  ```sql
  GRANT UPDATE ON '학생' TO 사용자
  ```
- 권한을 다른 사용자에게 부여할 수 있는 권한 부여 
  ```sql
  WITH GRANT OPTION
  ```

(4) REVOKE(권한회수) 명령어
- 객체권한 : 관리자가 사용자에게 부여했던 테이블에 대한 권한 회수
  ```sql
  REVOKE 권한 ON 테이블 FROM 사용자
  ```
- 시스템권한 : 테이블, 뷰, 프로시저 등을 생성, 삭제 권한 회수 
  ```sql
  REVOKE 권한 FROM 사용자
  ```
- Ex) 관리자가 사용자에게 학생 테이블에 대해 UPDATE 할 수 있는 권한 회수 
  ```sql
  REVOKE UPDATE ON '학생' FROM 사용자
  ```
- 부여된 사용자들의 권한까지 회수  
  ```sql
  CASCADE CONSTRAINT
  ```

<br>
<hr>

## 📚 CHAPTER2 응용 SQL 작성하기 

### ✍ 집계성 SQL 작성 

#### 1. 데이터 분석 함수 종류 (집그윈)
- 집계 함수 : 하나의 결과값을 반환
- 그룹 함수 : 중간 합계 분석 데이터 산출
- 윈도 함수  : DB를 사용한 온라인 분석 처리 용도로 사용하기 위해 표준 SQL에 추가된 기능

#### 2. 집계 함수

(1) 집계 함수 개념 : 여러 또는 테이블 전체 행으로부터 하나의 결과값 반환하는 함수

(2) 집계 함수 구문
```SQL
SELECT 컬럼1, 컬럼2, 집계함수
FROM 테이블명
[WHERE 조건]
GROUP BY 컬럼1, 컬럼2, ...
[HAVING 조건식(집계함수 포함)]
```

(3) 집계 함수 종류 
- COUNT : 줄 수 반환
- SUM : 컬럼 간 합계
- AVG : 컬럼 간 평균
- MAX : 컬럼 중 최대
- MIN : 컬럼 중 최소 
- STDDEV : 컬럼 간 표준편차
- VARIAN : 컬럼 간 분산

#### 3. 그룹 함수 
(1) 그룹 함수 개념 : 하나 이상의 컬럼을 기준으로 컬럼 값에 따라 그룹화하여 그룹별로 결과 출력

(2) 그룹 함수 종류 
- ROLLUP : 중간집계값 산출
- CUBE : 다차원 집계
- GROUPING SETS : 개별 집계

(3) ROLLUP 함수
- 중간 집계 값을 산출하기 위한 그룹 함수 
- 지정 컬럼의 수보다 하나 더 큰 레벨만큼의 중간 집계 값이 생성 (n+1) 
- 순서가 바뀌면 수행 결과가 바뀜 
  - 예제 
    - 테이블
      |부서명|직위|연봉|
      |------|---|---|
      |마케팅부|부장|4,000|
      |마케팅부|차장|2,000|
      |마케팅부|과장|1,500|
      |기획부|부장|3,800|
      |기획부|차장|1,800|
    - 소스
      ```SQL
      SELECT DEPT, JOB, SUM(SALARY)
      FROM DEPT_SALARY
      GROUP BY ROLLUP(DEPT, JOB); 
      ```
    - 결과
      |부서명|직위|연봉|
      |------|---|---|
      |마케팅부|부장|4,000|
      |마케팅부|차장|2,000|
      |마케팅부|과장|1,500|
      |마케팅부|(소계 n+1)|7,500|
      |기획부|부장|3,800|
      |기획부|차장|1,800|
      |기획부|(소계 n+1)|5,600|
      ||(총계)|13,100|

(4) CUBE 함수 

- 개념 : 결합 가능한 모든 값에 대해 다차원 집계를 생성하는 그룹 함수 
  - 예제 
    - 테이블
      |부서명|직위|연봉|
      |------|---|---|
      |마케팅부|부장|4,000|
      |마케팅부|차장|2,000|
      |마케팅부|과장|1,500|
      |기획부|부장|3,800|
      |기획부|차장|1,800|
    - 소스
      ```SQL
      SELECT DEPT, JOB, SUM(SALARY)
      FROM DEPT_SALARY
      GROUP BY CUBE(DEPT, JOB); 
      ```
    - 결과
      |부서명|직위|연봉|
      |------|---|---|
      |||13,100|
      ||부장|7,800|
      ||차장|3,800|
      ||과장|1,500|
      |마케팅부||7,500|
      |마케팅부|부장|4,000|
      |마케팅부|차장|2,000|
      |마케팅부|과장|1,500|
      |기획부||5,600|
      |기획부|부장|3,800|
      |기획부|차장|1,800|


(5) GROUPING SETS 함수 

- 개념 : 집계 대상 컬럼들에 대한 개별 집계를 구할 수 있으며, 순서와 무관한 결과를 얻을 수 있음
  - 예제 
    - 테이블
      |부서명|직위|연봉|
      |------|---|---|
      |마케팅부|부장|4,000|
      |마케팅부|차장|2,000|
      |마케팅부|과장|1,500|
      |기획부|부장|3,800|
      |기획부|차장|1,800|
    - 소스
      ```SQL
      SELECT DEPT, JOB, SUM(SALARY)
      FROM DEPT_SALARY
      GROUP BY GROUPING SETS(DEPT, JOB); 
      ```
    - 결과
      |부서명|직위|연봉|
      |------|---|---|
      |||13,100|
      ||부장|7,800|
      ||차장|3,800|
      ||과장|1,500|
      |마케팅부||7,500|
      |기획부||5,600|


#### 3. 윈도 함수 

(1) 윈도 함수 개념 : 온라인 분석 처리 용도로 사용하기 위해서 표준 SQL에 추가된 함수(OLAP 함수)

(2) 윈도 함수 구문
```sql
SELECT 함수명 (파라미터)
OVER
([PARTITION BY 컬럼1, ...]
[ORDER BY 컬럼A, ...])
FROM 테이블명
```

(3) 윈도 함수의 분류 **(순행비)**
- 순위 함수
  - 순위 계산
  - RANK, DENSE_RANK, ROW_NUMBER
- 행 순서 함수
  - 가장 먼저 나오거나 가장 뒤에 나오는 값, 이전/이후의 값들을 출력하는 함수
  - FIRST_VALUE, LAST_VALUE, LAG, LEAD
- 그룹 내 비율 함수  
  - 백분율을 보여주거나 행의 순서별 백분율 등 비율과 관련된 통계를 보여주는 함수
  - RATIO_TO_REPORT, PERCENT_RANK

(4) 순위 함수 
- RANK(공동 순위 변경)
  - 동일 순위의 레코드 존재 시 후순위는 넘어감
  - 2위 3개인 레코드 : 2위 2위 2위 5위 6위
- DENSE_RANK(공동 순위 무시)
  - 동일 순위의 레코드 존재 시에도 후순위를 넘어가지 않음
  - 2위 3개인 레코드 : 2위 2위 2위 3위 4위 
- ROW_NUMBER
  - 동일 순위의 값이 존재해도 이와 무관하게 연속 번호 부여
  - 2위 3개인 레코드 : 2위 3위 4위 5위 6위 

<BR>

- 예제 
  ```sql 
  SELECT NAME, 
        SALARY,
  RANK() OVER(ORDER BY SALARY DESC) A,
  DENSE_RANK() OVER(ORDER BY SALARY DESC) B,
  ROW_NUMBER() OVER(ORDER BY SALARY DESC) C,
  FROM EMPLOYEE;
  ``` 
- 결과

  |이름|연봉|A(RANK)|B(DENSE_RANK)|C(ROW_NUMBER)|
  |------|---|---|---|---|
  |장길산|3000|1|1|1|
  |임꺽정|2500|2|2|2|
  |홍길동|2500|2|2|3|
  |김철수|2200|4|3|4|
  |한유리|2000|5|4|5|

<BR>

(5) 행 순서 함수 
- FIRST_VALUE : 가장 먼저 나오는 값 찾음 / MIN과 동일한 결과 출력
- LAST_VALUE : 가장 늦게 나오는 값 찾음 / MAX와 동일한 결과 출력 
- LAG : 이전 로우의 값 반환
- LEAD : 이후 로우의 값 반환 
<BR>

- 예제 
  ```sql 
  SELECT NAME, 
        SALARY,
  FIRST_VALUE(NAME) OVER(ORDER BY SALARY DESC) A,
  LAST_VALUE(NAME) OVER(ORDER BY SALARY DESC) B,
  LAG(NAME) OVER(ORDER BY SALARY DESC) C,
  LEAD(NAME) OVER(ORDER BY SALARY DESC) D,
  FROM EMPLOYEE;
  ``` 
- 결과

  |이름|연봉|A(FV)|B(LV)|C(LAG)|D(LEAD)|
  |------|---|---|---|---|---|
  |장길산|3000|장길산|한유리||임꺽정|
  |임꺽정|2500|장길산|한유리|장길산|홍길동|
  |홍길동|2500|장길산|한유리|임꺽정|김철수|
  |김철수|2200|장길산|한유리|홍길동|한유리|
  |한유리|2000|장길산|한유리|김철수||

<BR>

(6) 그룹 내 비율 함수  
- RATIO_TO_REPORT
  - 그룹에 대해 합을 기준으로 각 로우의 상대적 비율 반환(결과 : 0~1)
- PERCENT_RANK
  - 제일 먼저 나오는 것을 0으로, 제일 늦게 나오는 것을 1로(결과 : 0~1)
  - 행의 순서별 백분율 구하는 함수 

<BR>

- 예제 
  ```sql 
  SELECT NAME, 
        SALARY,
        RATIO_TO_REPORT(SALARY) OVER() A,
        PERCENT_RANK() OVER(ORDER BY SALARY DESC) B,
  FROM EMPLOYEE;
  ``` 
- 결과

  |이름|연봉|A(RTR))|B(PR)|
  |------|---|---|---|
  |장길산|3000|0.2459|0|
  |임꺽정|2500|0.2049|0.25|
  |홍길동|2500|0.2049|0.25|
  |김철수|2200|0.1803|0.25|
  |한유리|2000|0.1639|1|

<br>
<hr>

## 📚 CHAPTER3 절차형 SQL 작성하기 

### ✍ 절차형 SQL

#### 1. 절차형 SQL 개념 
일반적인 개발 언어처럼 SQL 언어에서도 절차 지향적인 프로그램이 가능하도록 하는 트랜잭션 언어다. 

#### 2. 절차형 SQL 종류 (프사트)
- 프로시저 : 일련의 쿼리들을 하나의 함수처럼 실행하기 위한 쿼리의 집합 
- 사용자 정의함수 : 수행 결과를 단일 값으로 반환 (리턴함수 필요)
- 트리거 : 이벤트가 발생할 때마다 관련 작업이 자동으로 수행됨 

#### 3. 제어부 
(1) 조건문 
- IF문
  ```sql
  IF 조건 THEN
    문장;
  ELSIF 조건 THEN
    문장;
  ELSE
    문장;
  END IF;
  ```
- 간단한 케이스문 : 명확한 값을 가지는 조건에 따라 여러 개의 선택 중 하나를 취하고자 할 때 사용
  ```SQL
  CASE 변수 
    WHEN 값1 THEN
      SET 명령어; 
    WHEN 값2 THEN
      SET 명령어; 

    ELSE
      SET 명령어;
  END CASE; 
  ```
- 검색된 케이스문 
  ```SQL
  CASE 변수 
    WHEN 조건1 THEN
      SET 명령어; 
    WHEN 조건2 THEN
      SET 명령어; 

    ELSE
      SET 명령어;
  END CASE; 
  ```

(2) 반복문 
- LOOP문
  ```SQL 
  LOOP
    문장;
    EXIT WHEN 탈출조건; 
  END LOOP;
  ```

- WHILE문
  ```SQL
  WHILE 반복 조건 LOOP
    문장; 
  EXIT WHEN 탈출조건; 
  END LOOP;
  ```

- FOR LOOP문
  ```SQL
  FOR 인덱스 IN 시작값..종료값
  LOOP
    문장; 
  END LOOP;
  ```
(3) 예외부 
- EXCEPTION
  ```SQL
  EXCEPTION
    WHEN 조건 THEN
      SET 명령어; 
  ```
<br>


### ✍ 프로시저 

#### 1. 프로시저 개념 
프로시저는 일련의 쿼리들을 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합이다. 

#### 2. 프로시저 구성 (디비컨 SET) 
- 선언부 (DECLARE)
- 시작/종료부 (BEGIN/END)
- 제어부 (CONTROL)
- SQL 
- 예외부 (EXCEPTION) 
- 실행부 (TRANSACTION)

#### 3. 프로시저 문법 
```SQL
CREATE [OR REPLACE] PROCEDURE 프로시저명
(파라미터명 [IN|OUT|INOUT] 데이터타입,...)
IS
  변수선언
BEGIN
  명령어;
[COMMIT|ROLLBACK]
END; 
```
- OR REPLACE : 기존 프로시저 존재 시에 현재 컴파일하는 내용으로 덮어씀 
- 모드
  - IN : 운영체제에서 프로시저로
  - OUT : 프로시저에서 운영체지로
  - INOUT : 두 가지 기능 동시에 수행
- BEGIN : 프로시저 시작
- COMMIT
  - 하나의 트랜잭션이 성공적으로 끝났고, 데이터베이스가 일관성 있는 상태에 있을 때 하나의 트랜잭션이 끝났을 때 사용하는 연산 
- ROLLBACK : 원자성이 깨질 경우 처음부터 다시 시작하거나, 부분적으로 연산을 취소

#### 4. 프로시저 호출문 작성
```SQL 
EXECUTE 프로시저명(파라미터1, 파라미터2);
```
<br>

### ✍ 사용자 정의함수 

#### 1. 사용자 정의함수 개념 
일련의 SQL 처리를 수행하고, 수행 결과를 단일 값으로 반환할 수 있는 절차형 SQL이다. 

#### 2. 문법
- 모드 : IN
- RETURN : 단일 값을 정의

<br>

### ✍ 트리거
#### 1. 트리거의 개념  
데이터베이스 시스템에서 삽입, 삭제, 갱신 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL이다.

#### 2. 종류 
- 행 트리거 : 데이터 변화가 생길 때마다 실행 
- 문장 트리거 : 트리거에 의해 단 한 번 실행

#### 3. 문법 
- 순서 : BEFORE | AFTER

<br>
<hr>

## 📚 CHAPTER4 데이터 조작 프로시저 최적화 

### ✍ 데이터 조작 프로시저 성능개선 

#### 1. 옵티마이저 개념 
- SQL을 가장 빠르고 효율적으로 수행할 최적의 처리경로를 생성해주는 DBMS 내부의 핵심엔진이다. 
- 옵티마이저가 생성한 SQL 처리경로를 실행계획이라고 부른다. 

#### 2. 옵티마이저 유형 
- 규칙기반 옵티마이저(RBO)
- 비용기반 옵티마이저(CBO)

#### 3. 힌트 사용 
- SQL 성능 개선의 핵심 부분으로 옵티마이저의 실행 계획을 원하는대로 변경할 수 있게 한다.
- 옵티마이저가 항상 최선의 실행 계획을 수립할 수 없어 명시적인 힌트를 통해 실행 계획을 변경한다. 